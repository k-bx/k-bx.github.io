<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>./articles/propositions-as-types-missing-links.md</title>
  <style>
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style>
code.sourceCode > span { display: inline-block; line-height: 1.25; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="https://k-bx.github.io/gothic.css" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<h1 id="propositions-as-types-some-missing-links">Propositions as Types: Some Missing Links</h1>
<p>Iâ€™ve recently started studying Topology, which turned out to be a topic filled with set theory and theorems around it. Unfortunately, my brain was well-poisoned by Type Theory by the time Iâ€™ve started, so I couldnâ€™t help but itch my hands in attempt of encoding things in Type Theory.</p>
<p>In this blog post, I will list the things I consider missing (or rarely mentioned) when people are talking about Propositions-as-Types with regards to proving set theory theorems in Type Theory, and will show a simple proof of a theorem from the book â€œTopology Without Tearsâ€, one merely about Topology but rather a set-theoretic exercise in proofs.</p>
<h2 id="the-missing-links">The Missing Links</h2>
<p>List of things I donâ€™t see mentioned very often:</p>
<p><strong>Equality of Sets</strong>. If sets are types, then what would their equality look like? I think there are two options here: first is to use the notion of Isomorphism, the second is to assume Univalence and get equality-via-isomorphism â€œfor freeâ€. In this postâ€™s example, Iâ€™ll take the former approach. So if we are required to prove that sets <code>A</code> and <code>B</code> are equal, we will be building an element of type <code>A â‰ƒ B</code>. Just to remind ourselves what an Isomorphism is. For some types <code>A</code> and <code>B</code>, an isomorphism between them is defined as:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb1-1"><a href="#cb1-1"></a><span class="kw">record</span> <span class="ot">_</span>â‰ƒ<span class="ot">_</span> <span class="ot">(...)</span> <span class="kw">where</span></span>
<span id="cb1-2"><a href="#cb1-2"></a>  <span class="kw">field</span></span>
<span id="cb1-3"><a href="#cb1-3"></a>    <span class="kw">to</span>   <span class="ot">:</span> A <span class="ot">â†’</span> B</span>
<span id="cb1-4"><a href="#cb1-4"></a>    from <span class="ot">:</span> B <span class="ot">â†’</span> A</span>
<span id="cb1-5"><a href="#cb1-5"></a>    fromâˆ˜to <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">(</span>x <span class="ot">:</span> A<span class="ot">)</span> <span class="ot">â†’</span> from <span class="ot">(</span><span class="kw">to</span> x<span class="ot">)</span> â‰¡ x</span>
<span id="cb1-6"><a href="#cb1-6"></a>    toâˆ˜from <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">(</span>y <span class="ot">:</span> B<span class="ot">)</span> <span class="ot">â†’</span> <span class="kw">to</span> <span class="ot">(</span>from y<span class="ot">)</span> â‰¡ y</span></code></pre></div>
<p>An Isomorphism is a record of four fields:</p>
<ul>
<li>a function taking us from <code>A</code> to <code>B</code></li>
<li>a function bringing us backwards</li>
<li>an element of type <code>from (to x) â‰¡ x</code>, proving that if we go from <code>A</code> to <code>B</code> and back using our implementation, weâ€™d get the same element we started from</li>
<li>and a similar law <code>to (from y) â‰¡ y</code> going the other direction</li>
</ul>
<p>So, for example, we could then provide an isomorphism between numbers and their string representations via encoding them as Roman Numbers.</p>
<p><strong>Subsets</strong>. There are actually two distinct approaches Iâ€™ve encountered with regard to subsets, and weâ€™re going to use both. One is a.k.a. the HoTT book, Chapter 3.5, encoding a subset of some set <code>A</code> of elements satisfying some predicate <code>P</code> (<code>{ x âˆˆ A | P(x)}</code>) as: <span class="math display">\[
\Sigma_{x : A}P(x)
\]</span> So, a type describing a pair of element <code>x : A</code> and a proof that that element satisfies some predicate <code>P</code> is describing all the values which are members of this subset.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb2-1"><a href="#cb2-1"></a><span class="co">-- Btw to not confuse sets and types, we&#39;ll use Typeâ‚€ and Typeâ‚</span></span>
<span id="cb2-2"><a href="#cb2-2"></a><span class="co">-- instead of the usual Agda&#39;s `Set` and `Setâ‚` types</span></span>
<span id="cb2-3"><a href="#cb2-3"></a></span>
<span id="cb2-4"><a href="#cb2-4"></a><span class="co">-- Type of some predicate</span></span>
<span id="cb2-5"><a href="#cb2-5"></a>Pred <span class="ot">:</span> Typeâ‚€ <span class="ot">â†’</span> Typeâ‚</span>
<span id="cb2-6"><a href="#cb2-6"></a>Pred X <span class="ot">=</span> X <span class="ot">â†’</span> Typeâ‚€</span>
<span id="cb2-7"><a href="#cb2-7"></a></span>
<span id="cb2-8"><a href="#cb2-8"></a><span class="co">-- Type of a subset</span></span>
<span id="cb2-9"><a href="#cb2-9"></a>Subset <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">{</span>X <span class="ot">:</span> Typeâ‚€<span class="ot">}</span> <span class="ot">â†’</span> Pred X <span class="ot">â†’</span> Typeâ‚€</span>
<span id="cb2-10"><a href="#cb2-10"></a>Subset <span class="ot">{</span>X<span class="ot">}</span> P <span class="ot">=</span> Î£[ x âˆˆ X ] <span class="ot">(</span>P x<span class="ot">)</span></span>
<span id="cb2-11"><a href="#cb2-11"></a></span>
<span id="cb2-12"><a href="#cb2-12"></a><span class="co">-- To those who don&#39;t remember, in the syntax Î£[ x âˆˆ X ] (P x)</span></span>
<span id="cb2-13"><a href="#cb2-13"></a><span class="co">-- the symbol `âˆˆ` essentially means &quot;has type&quot;. So it reads</span></span>
<span id="cb2-14"><a href="#cb2-14"></a><span class="co">-- &quot;for some x that has type X, there exists an element of `P x`&quot;</span></span></code></pre></div>
<p>The second notion that I was thinking about was to use the notion of Embedding, something very much like Isomorphism, but without one law:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb3-1"><a href="#cb3-1"></a><span class="kw">record</span> <span class="ot">_</span>â‰²<span class="ot">_</span> <span class="ot">(</span>A B <span class="ot">:</span> Typeâ‚€<span class="ot">)</span> <span class="ot">:</span> Typeâ‚€ <span class="kw">where</span></span>
<span id="cb3-2"><a href="#cb3-2"></a>  <span class="kw">field</span></span>
<span id="cb3-3"><a href="#cb3-3"></a>    <span class="kw">to</span>      <span class="ot">:</span> A <span class="ot">â†’</span> B</span>
<span id="cb3-4"><a href="#cb3-4"></a>    from    <span class="ot">:</span> B <span class="ot">â†’</span> A</span>
<span id="cb3-5"><a href="#cb3-5"></a>    fromâˆ˜to <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">(</span>x <span class="ot">:</span> A<span class="ot">)</span> <span class="ot">â†’</span> from <span class="ot">(</span><span class="kw">to</span> x<span class="ot">)</span> â‰¡ x</span></code></pre></div>
<p>So, for example, we can prove the embedding of <code>Bool</code>s to <code>Nat</code>s by saying that <code>True</code> will map to <code>1</code> and <code>False</code> will map to <code>0</code>. Then <code>to(from(x)) â‰¡ x</code> will hold for both, <code>x</code> being <code>True</code> or <code>False</code>, but the opposite <code>from(to(x))</code> would clearly fail for anything <code>&gt; 1</code> (<code>from(to(3)) â‰¡ 1</code>).</p>
<p><strong>Set of subsets.</strong> An interesting one to crack to me was the notion of a â€œset of subsetsâ€ back from when Iâ€™ve studied what a Topology is. So, if a subset is a pair of element of <code>X</code> and a proof that it satisfies some predicate <code>P</code>, then set of subsets must be a pair of <em>some predicate describing a subset</em> and an instance of a <em>predicate on that predicate</em>:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb4-1"><a href="#cb4-1"></a>PredOnPred <span class="ot">:</span> Typeâ‚€ <span class="ot">â†’</span> Typeâ‚</span>
<span id="cb4-2"><a href="#cb4-2"></a>PredOnPred X <span class="ot">=</span> <span class="ot">(</span>X <span class="ot">â†’</span> Typeâ‚€<span class="ot">)</span> <span class="ot">â†’</span> Typeâ‚€</span>
<span id="cb4-3"><a href="#cb4-3"></a></span>
<span id="cb4-4"><a href="#cb4-4"></a>SetOfSubs <span class="ot">:</span> <span class="ot">{</span>X <span class="ot">:</span> Typeâ‚€<span class="ot">}</span> <span class="ot">â†’</span> <span class="ot">(</span>PredOnPred X<span class="ot">)</span> <span class="ot">â†’</span> Typeâ‚</span>
<span id="cb4-5"><a href="#cb4-5"></a>SetOfSubs <span class="ot">{</span>X<span class="ot">}</span> â„™ <span class="ot">=</span> Î£[ P âˆˆ Pred X ] <span class="ot">(</span>â„™ P<span class="ot">)</span></span></code></pre></div>
<p>I donâ€™t know the usefullness of this to be honest, but for our purposes it seems ok and doesnâ€™t look wrong.</p>
<p><strong>Set belonging to a Set of Subsets</strong></p>
<p>How do we say that something is present in a given set of subsets? Probably give back the predicate and show all elements satisfying it are isomorphic to S</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb5-1"><a href="#cb5-1"></a><span class="ot">_</span>âˆˆs<span class="ot">_</span> <span class="ot">:</span> <span class="ot">{</span>X <span class="ot">:</span> Typeâ‚€<span class="ot">}</span></span>
<span id="cb5-2"><a href="#cb5-2"></a>     <span class="ot">â†’</span> <span class="ot">{</span>â„™ <span class="ot">:</span> PredOnPred X<span class="ot">}</span></span>
<span id="cb5-3"><a href="#cb5-3"></a>     <span class="ot">â†’</span> <span class="ot">(</span>S <span class="ot">:</span> Typeâ‚€<span class="ot">)</span> <span class="ot">â†’</span> <span class="ot">(</span>SetOfSubs â„™<span class="ot">)</span> <span class="ot">â†’</span> Typeâ‚</span>
<span id="cb5-4"><a href="#cb5-4"></a><span class="ot">_</span>âˆˆs<span class="ot">_</span> <span class="ot">{</span>X<span class="ot">}</span> S â„™ <span class="ot">=</span></span>
<span id="cb5-5"><a href="#cb5-5"></a>  Î£[ P âˆˆ Pred X ]</span>
<span id="cb5-6"><a href="#cb5-6"></a>  <span class="ot">(</span> <span class="ot">âˆ€</span> <span class="ot">(</span>x <span class="ot">:</span> X<span class="ot">)</span> <span class="ot">â†’</span> <span class="ot">(</span>P x â‰ƒ S<span class="ot">))</span></span></code></pre></div>
<p><strong>Unions, Intersections. Finite and Infinite.</strong>. The first thing that you see when you study Topology is that a Topology has a property involving Unions and Intersections, and not just that, but theyâ€™re also finite and infinite.</p>
<p>First, letâ€™s deal with infinite ones. They are well-known in Type Theory, and are represented as a Sum type (â€œorâ€) and a Product type (â€œandâ€). So:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb6-1"><a href="#cb6-1"></a><span class="co">-- This is a Union of A and B: A âŠ B</span></span>
<span id="cb6-2"><a href="#cb6-2"></a></span>
<span id="cb6-3"><a href="#cb6-3"></a><span class="co">-- This is an Intersection of A and B: A Ã— B</span></span></code></pre></div>
<p>Now, but what does it take to be an infinite union? Well, if you look not at what an infinite union is exactly, but at <a href="https://en.wikipedia.org/wiki/Union_(set_theory)#Arbitrary_unions">what you can do with it</a>, youâ€™ll find that the only useful thing is this: <span class="math display">\[
x \in \bigcup \mathbf{M} \iff \exists A \in \mathbf{M},\ x \in A
\]</span> E.g. to say that x is in some union is the same thing as to say that there exists an element of that union which x belongs to. Great!</p>
<p>Now, for the purposes Iâ€™ve had, Iâ€™ve needed a union of specifically some set of subsets, so Iâ€™ve enriched the notion just mentioned with an additional fact that whatever the element of the union we cat, itâ€™s going to be a subset of that set.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb7-1"><a href="#cb7-1"></a>Union <span class="ot">:</span> <span class="ot">{</span>X <span class="ot">:</span> Typeâ‚€<span class="ot">}</span></span>
<span id="cb7-2"><a href="#cb7-2"></a>      <span class="ot">â†’</span> <span class="ot">{</span>â„™ <span class="ot">:</span> PredOnPred X<span class="ot">}</span></span>
<span id="cb7-3"><a href="#cb7-3"></a>      <span class="ot">â†’</span> <span class="ot">(</span>J <span class="ot">:</span> Typeâ‚€<span class="ot">)</span></span>
<span id="cb7-4"><a href="#cb7-4"></a>      <span class="ot">â†’</span> <span class="ot">(</span>ğµ <span class="ot">:</span> SetOfSubs â„™<span class="ot">)</span></span>
<span id="cb7-5"><a href="#cb7-5"></a>      <span class="ot">â†’</span> Typeâ‚</span>
<span id="cb7-6"><a href="#cb7-6"></a>Union J ğµ <span class="ot">=</span></span>
<span id="cb7-7"><a href="#cb7-7"></a>  Î£[ j âˆˆ J ]</span>
<span id="cb7-8"><a href="#cb7-8"></a>  Î£[ Bâ±¼ âˆˆ Typeâ‚€ ]</span>
<span id="cb7-9"><a href="#cb7-9"></a>  <span class="ot">(</span>Bâ±¼ âˆˆs ğµ<span class="ot">)</span></span></code></pre></div>
<p>So we say that <code>J</code> is some â€œindex setâ€ on our type <code>X</code>, and that a union (somewhat resembling the notion of a subset) is a triple of a specific index, a type for a subset at that index, and a proof that itâ€™s a subset of <code>ğµ</code>.</p>
<h2 id="lets-have-some-fun-now">Letâ€™s Have Some Fun Now</h2>
<p>Iâ€™d like us to stop now with the code snippets describing all that useless conceptual code and do something practical! Letâ€™s prove a proposition now. Itâ€™s going to be an arbitrary-chosen Proposition 2.3.2 from the book <a href="http://www.topologywithouttears.net/">Topology Without Tears</a>. Here it is, together with its â€œunwrappingâ€ and the proof:</p>
<figure>
<img src="./propositions-as-types-missing-links/prop232_1.png" alt="" /><figcaption>prop232_1</figcaption>
</figure>
<figure>
<img src="./propositions-as-types-missing-links/prop232_2.png" alt="" /><figcaption>prop232_1</figcaption>
</figure>
<figure>
<img src="./propositions-as-types-missing-links/prop232_3.png" alt="" /><figcaption>prop232_1</figcaption>
</figure>
<p>Weâ€™re only going to bother ourselves with the second part of the proof, the â€œConverselyâ€ one. The first part is left to the reader as an exercise.</p>
<p>To visualise what weâ€™re doing here, hereâ€™s a fine drawing of mine:</p>
<figure>
<img src="./propositions-as-types-missing-links/prop232_drawing.jpg" alt="" /><figcaption>prop232_drawing</figcaption>
</figure>
<p>The proof goes by saying that since for every <code>x</code> in <code>U</code> we see that itâ€™s also in some <code>B âŠ† U</code>, then obviously <code>U</code> is eqal to a union of all such <code>B</code>s. Thatâ€™s exactly what weâ€™re going to encode.</p>
<p>Iâ€™m going to just throw the code at you here, and then explain few things that were missing from before, and few places Iâ€™ve had to struggle with the most.</p>
<p>Full code available at <a href="https://github.com/k-bx/k-bx.github.io/blob/master/articles/propositions-as-types-missing-links/TheMissingLinks.agda">TheMissingLinks.agda</a>:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb8-1"><a href="#cb8-1"></a><span class="co">-- &quot;Topology without tears&quot; 2.3.2 constructively</span></span>
<span id="cb8-2"><a href="#cb8-2"></a><span class="co">--</span></span>
<span id="cb8-3"><a href="#cb8-3"></a><span class="co">-- 2.3.2 Let (X, Ï„) be a topological space. A family B of open subsets</span></span>
<span id="cb8-4"><a href="#cb8-4"></a><span class="co">-- of X is a basis for Ï„ if and only if for any point x belonging to</span></span>
<span id="cb8-5"><a href="#cb8-5"></a><span class="co">-- any open set U , there is a B âˆˆ B such that x âˆˆ B âŠ† U.</span></span>
<span id="cb8-6"><a href="#cb8-6"></a><span class="co">--</span></span>
<span id="cb8-7"><a href="#cb8-7"></a><span class="co">-- This only proves the second part (given ... proves that ğµ is a basis)</span></span>
<span id="cb8-8"><a href="#cb8-8"></a><span class="co">--</span></span>
<span id="cb8-9"><a href="#cb8-9"></a>prop232</span>
<span id="cb8-10"><a href="#cb8-10"></a>  <span class="ot">:</span> <span class="ot">(</span>X <span class="ot">:</span> Typeâ‚€<span class="ot">)</span></span>
<span id="cb8-11"><a href="#cb8-11"></a>  <span class="ot">â†’</span> <span class="ot">{</span>â„™â‚ <span class="ot">:</span> PredOnPred X<span class="ot">}</span></span>
<span id="cb8-12"><a href="#cb8-12"></a>  <span class="ot">â†’</span> <span class="ot">{</span>â„™â‚‚ <span class="ot">:</span> PredOnPred X<span class="ot">}</span></span>
<span id="cb8-13"><a href="#cb8-13"></a>  <span class="ot">â†’</span> <span class="ot">(</span>Ï„ <span class="ot">:</span> SetOfSubs â„™â‚<span class="ot">)</span>  <span class="co">-- we don&#39;t use the whole structure of Topology here</span></span>
<span id="cb8-14"><a href="#cb8-14"></a>  <span class="ot">â†’</span> <span class="ot">(</span>ğµ <span class="ot">:</span> SetOfSubs â„™â‚‚<span class="ot">)</span></span>
<span id="cb8-15"><a href="#cb8-15"></a>  <span class="ot">â†’</span> <span class="ot">(</span>givenâ‚ <span class="ot">:</span> <span class="ot">âˆ€</span> <span class="ot">(</span>U <span class="ot">:</span> Typeâ‚€<span class="ot">)</span></span>
<span id="cb8-16"><a href="#cb8-16"></a>            <span class="ot">â†’</span> <span class="ot">(</span>U â‰² X<span class="ot">)</span></span>
<span id="cb8-17"><a href="#cb8-17"></a>            <span class="ot">â†’</span> <span class="ot">(</span>U âˆˆs Ï„<span class="ot">)</span></span>
<span id="cb8-18"><a href="#cb8-18"></a>            <span class="ot">â†’</span> <span class="ot">(</span>x <span class="ot">:</span> U<span class="ot">)</span></span>
<span id="cb8-19"><a href="#cb8-19"></a>            <span class="ot">â†’</span> Î£[ B âˆˆ Typeâ‚€ ]</span>
<span id="cb8-20"><a href="#cb8-20"></a>              Î£[ <span class="ot">_</span> âˆˆ <span class="ot">(</span>B âˆˆs ğµ<span class="ot">)</span> ]</span>
<span id="cb8-21"><a href="#cb8-21"></a>              Î£[ Bâ‰²U âˆˆ B â‰² U ]</span>
<span id="cb8-22"><a href="#cb8-22"></a>              Î£[ b âˆˆ B ]</span>
<span id="cb8-23"><a href="#cb8-23"></a>              <span class="ot">((_</span>â‰²<span class="ot">_.</span><span class="kw">to</span> Bâ‰²U b<span class="ot">)</span> â‰¡ x<span class="ot">)</span></span>
<span id="cb8-24"><a href="#cb8-24"></a>              <span class="ot">)</span></span>
<span id="cb8-25"><a href="#cb8-25"></a>  <span class="ot">â†’</span> <span class="ot">(âˆ€</span> <span class="ot">(</span>V <span class="ot">:</span> Typeâ‚€<span class="ot">)</span></span>
<span id="cb8-26"><a href="#cb8-26"></a>     <span class="ot">â†’</span> <span class="ot">(</span>V â‰² X<span class="ot">)</span></span>
<span id="cb8-27"><a href="#cb8-27"></a>     <span class="ot">â†’</span> V âˆˆs Ï„</span>
<span id="cb8-28"><a href="#cb8-28"></a>     <span class="ot">â†’</span> UnionTruncation V ğµ</span>
<span id="cb8-29"><a href="#cb8-29"></a>     <span class="ot">â†’</span> Î£[ J âˆˆ Typeâ‚€ ]</span>
<span id="cb8-30"><a href="#cb8-30"></a>       <span class="ot">(</span>V â‰ƒ <span class="ot">(</span>Union J ğµ<span class="ot">))</span></span>
<span id="cb8-31"><a href="#cb8-31"></a>    <span class="ot">)</span></span>
<span id="cb8-32"><a href="#cb8-32"></a>prop232 X Ï„ ğµ givenâ‚ V Vâ‰²X VâˆˆsÏ„ unionTruncation</span>
<span id="cb8-33"><a href="#cb8-33"></a>  <span class="ot">=</span> V</span>
<span id="cb8-34"><a href="#cb8-34"></a>  , <span class="kw">record</span></span>
<span id="cb8-35"><a href="#cb8-35"></a>    <span class="ot">{</span> <span class="kw">to</span> <span class="ot">=</span> <span class="ot">Î»</span> v <span class="ot">â†’</span> <span class="kw">let</span> <span class="ot">(</span> Bâ‚“ , Bâˆˆsğµ , Bâ‰²U , b , bâ†’v <span class="ot">)</span> <span class="ot">=</span> givenâ‚ V Vâ‰²X VâˆˆsÏ„ v</span>
<span id="cb8-36"><a href="#cb8-36"></a>                  <span class="kw">in</span> v , Bâ‚“ , Bâˆˆsğµ</span>
<span id="cb8-37"><a href="#cb8-37"></a>    <span class="ot">;</span> from <span class="ot">=</span> <span class="ot">Î»{</span> <span class="ot">(</span>x , Bâ‚“ , Bâ‚“âˆˆsğµ<span class="ot">)</span> <span class="ot">â†’</span> x<span class="ot">}</span></span>
<span id="cb8-38"><a href="#cb8-38"></a>    <span class="ot">;</span> fromâˆ˜to <span class="ot">=</span> <span class="ot">Î»</span> x <span class="ot">â†’</span> refl</span>
<span id="cb8-39"><a href="#cb8-39"></a>    <span class="ot">;</span> toâˆ˜from <span class="ot">=</span> <span class="ot">Î»</span> y <span class="ot">â†’</span> unionTruncation</span>
<span id="cb8-40"><a href="#cb8-40"></a>                         <span class="ot">(</span> projâ‚ y</span>
<span id="cb8-41"><a href="#cb8-41"></a>                         , projâ‚ <span class="ot">(</span>givenâ‚ V Vâ‰²X VâˆˆsÏ„ <span class="ot">(</span>projâ‚ y<span class="ot">))</span></span>
<span id="cb8-42"><a href="#cb8-42"></a>                         , projâ‚ <span class="ot">(</span>projâ‚‚ <span class="ot">(</span>givenâ‚ V Vâ‰²X VâˆˆsÏ„ <span class="ot">(</span>projâ‚ y<span class="ot">))))</span></span>
<span id="cb8-43"><a href="#cb8-43"></a>                         y</span>
<span id="cb8-44"><a href="#cb8-44"></a>                         refl</span>
<span id="cb8-45"><a href="#cb8-45"></a>    <span class="ot">}</span></span></code></pre></div>
<p>So, what you can see is that weâ€™re proving <code>Î£[ J âˆˆ Typeâ‚€ ] (V â‰ƒ (Union J ğµ))</code> here, meaning that weâ€™ll provide what the index of the union is, and weâ€™ll prove that <code>V</code> is isomorphic to that union.</p>
<p>Few things to note here.</p>
<p><strong>Union Truncation</strong>. Youâ€™ve probably noticed that Iâ€™ve smuggled some <code>unionTruncation</code> stuff. What is that exactly? Well, as Iâ€™ve been trying to prove the forementioned isomorphism, I was able to prove the <code>fromâˆ˜to</code> part easily, but had struggles with the <code>toâˆ˜from</code> one. Somehow, going from an element of union into <code>V</code> and then back, didnâ€™t necessary give me back exactly the same element of the Union. This was my â€œgoalâ€ back in the days:</p>
<pre><code>  (x , projâ‚ (givenâ‚ V Vâ‰²X VâˆˆsÏ„ x) , projâ‚ (projâ‚‚ (givenâ‚ V Vâ‰²X VâˆˆsÏ„ x)))
â‰¡ (x , Bâ‚“ , Bâ‚“âˆˆSğµ)</code></pre>
<p>After giving it a thought, Iâ€™ve figured that this isnâ€™t necessarily the case, actually. An element of a Union, as itâ€™s currently defined, is a triple, giving you an element, a subst it belongs to and a proof of that being subset. But nothing guarantees you that the subset of an element will always be the same!</p>
<p>But we really donâ€™t care. All we care here is that the elements of <code>V</code> are the same as the elements of the union. So, I needed to come up with a notion very similar to Truncation from the HoTT book, but that would keep the element (donâ€™t truncate <code>x</code>), but truncate both the subset (always pick same subset for an element) and the proof (proofs are all the same). Hereâ€™s how it looks like:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb10-1"><a href="#cb10-1"></a>UnionTruncation</span>
<span id="cb10-2"><a href="#cb10-2"></a>  <span class="ot">:</span> <span class="ot">{</span>X <span class="ot">:</span> Typeâ‚€<span class="ot">}</span></span>
<span id="cb10-3"><a href="#cb10-3"></a>  <span class="ot">â†’</span> <span class="ot">{</span>â„™ <span class="ot">:</span> PredOnPred X<span class="ot">}</span></span>
<span id="cb10-4"><a href="#cb10-4"></a>  <span class="ot">â†’</span> <span class="ot">(</span>J <span class="ot">:</span> Typeâ‚€<span class="ot">)</span></span>
<span id="cb10-5"><a href="#cb10-5"></a>  <span class="ot">â†’</span> <span class="ot">(</span>ğµ <span class="ot">:</span> SetOfSubs â„™<span class="ot">)</span></span>
<span id="cb10-6"><a href="#cb10-6"></a>  <span class="ot">â†’</span> Typeâ‚</span>
<span id="cb10-7"><a href="#cb10-7"></a>UnionTruncation J ğµ <span class="ot">=</span></span>
<span id="cb10-8"><a href="#cb10-8"></a>  <span class="ot">(</span>j <span class="ot">:</span> Union J ğµ<span class="ot">)</span> <span class="ot">â†’</span> <span class="ot">(</span>k <span class="ot">:</span> Union J ğµ<span class="ot">)</span> <span class="ot">â†’</span> <span class="ot">(</span>projâ‚ j â‰¡ projâ‚ k<span class="ot">)</span> <span class="ot">â†’</span> j â‰¡ k</span></code></pre></div>
<p>With this, the proof was complete.</p>
<p><strong>Level-polymorphic Isomorphism</strong>. Another thing you might mention is that the isomorphism code has been converted to be level-polymorphic. Not a big deal, but I thought itâ€™s worth noting:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb11-1"><a href="#cb11-1"></a><span class="kw">record</span> <span class="ot">_</span>â‰ƒ<span class="ot">_</span> <span class="ot">{</span>l m<span class="ot">}</span> <span class="ot">(</span>A <span class="ot">:</span> Type l<span class="ot">)</span> <span class="ot">(</span>B <span class="ot">:</span> Type m<span class="ot">)</span> <span class="ot">:</span> Type <span class="ot">(</span>l âŠ” m<span class="ot">)</span> <span class="kw">where</span></span></code></pre></div>
<h2 id="other-things">Other things</h2>
<p>Other things worth noting that are present in set theory:</p>
<p><strong>Dynamic Membership Checking</strong>. Proofs in set theory often go on and say â€œif x is a member of X then â€¦â€. Iâ€™m not touching examples of these proofs here, but I think this should be mentioned explicitly. Most situation like this either translate in a â€œthere exists an <code>x : X</code>â€, or involve the Law of Excluded Middle</p>
<p><strong>Sameness of an element</strong>. Itâ€™s often said that â€œif an element x is a member if U, itâ€™s also a member of Vâ€, but if U and V are distinct types, <code>x</code> canâ€™t have both types. In Type Theory, this has to have a bit more structure.</p>
<p>In our proof, this can be seen as <code>((_â‰²_.to Bâ‰²U b) â‰¡ x)</code>. Instead of saying â€œx is also in Bâ€, we have to say â€œthere is some <code>b</code> in <code>B</code>, and converted to <code>U</code> via isomorphism, itâ€™s equal to <code>x</code>â€.</p>
<h2 id="conclusion">Conclusion</h2>
<p>Doing set-theoretic proofs in Agda is still not an easy task, but itâ€™s fun and I think it gave me a better understanding of precisely what concepts I am dealing with. The most useful one was the notion of Union Truncation, the idea around â€œwhat does it mean for two unions to be the sameâ€. Type Theory gives us a bit more power here, since we can distinguish different unions even if they have the same elements in them.</p>
<p>Iâ€™m really happy that this project didnâ€™t fail, and will probably continue exploring Propositions-as-Types approach towards Topology propositions.</p>
<p>Please send your feedback in Issues or PRs in <a href="https://github.com/k-bx/k-bx.github.io">this blogâ€™s repo</a>.</p>
</body>
</html>
